[{"/Users/venecia/rebel/ocr-tesseract/src/App.js":"1","/Users/venecia/rebel/ocr-tesseract/src/helpers/image.js":"2","/Users/venecia/rebel/ocr-tesseract/src/helpers/ocr.js":"3","/Users/venecia/rebel/ocr-tesseract/src/reportWebVitals.js":"4","/Users/venecia/rebel/ocr-tesseract/src/DrawAnnotations/index.jsx":"5","/Users/venecia/rebel/ocr-tesseract/src/index.js":"6"},{"size":4509,"mtime":1612256133086,"results":"7","hashOfConfig":"8"},{"size":374,"mtime":1612251493415,"results":"9","hashOfConfig":"8"},{"size":7500,"mtime":1612252531769,"results":"10","hashOfConfig":"8"},{"size":362,"mtime":1612248471037,"results":"11","hashOfConfig":"8"},{"size":761,"mtime":1612255857581,"results":"12","hashOfConfig":"8"},{"size":500,"mtime":1612248471036,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"uywxzc",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/venecia/rebel/ocr-tesseract/src/App.js",[],"/Users/venecia/rebel/ocr-tesseract/src/helpers/image.js",[],["28","29"],"/Users/venecia/rebel/ocr-tesseract/src/helpers/ocr.js",["30","31","32"],"import Tesseract from 'tesseract.js';\nimport moment from 'moment';\n\n// date format with space\nconst formatWithSpace = [\n  'D MMMM, YYYY',\n  'D MMM, YYYY',\n  // ////\n  'MMMM D, YYYY',\n  'MMMM D, YY',\n  'MMM D, YYYY',\n  'MMM D, YY',\n\n  'MMMM DD, YYYY',\n  'MMMM DD, YY',\n  'MMM DD, YYYY',\n  'MMM DD, YY',\n\n  'MMMM Do, YYYY',\n  'MMMM Do, YY',\n  'MMM Do, YYYY',\n  'MMM Do, YY',\n\n  // ////////\n  'YYYY, MMMM D',\n  'YY, MMMM D',\n  'YYYY, MMM D',\n  'YY, MMM D',\n\n  'YYYY, MMMM DD',\n  'YY, MMMM DD',\n  'YYYY, MMM DD',\n  'YY, MMM DD',\n\n  'YYYY, MMMM Do',\n  'YY, MMMM Do',\n  'YYYY, MMM Do',\n  'YY, MMM Do',\n\n  // MONTH DATE YEAR\n  'M D YYYY',\n  'M D YY',\n  'MM D YYYY',\n  'MM D YY',\n  'M DD YYYY',\n  'M DD YY',\n  'MM DD YYYY',\n  'MM DD YY',\n  \n  // DATE MONTH YEAR\n  'D M YYYY',\n  'D M YY',\n  'DD M YYYY',\n  'DD M YY',\n  'D MM YYYY',\n  'D MM YY',\n  'DD MM YYYY',\n  'DD MM YY',\n  \n  // YEAR MONTH DATE\n  'YYYY M D',\n  'YY M D',\n  'YYYY MM D',\n  'YY MM D',\n  'YYYY M DD',\n  'YY M DD',\n  'YYYY MM DD',\n  'YY MM DD',\n  \n  // YEAR DATE MONTH\n  'YYYY D M',\n  'YY D M',\n  'YYYY DD M',\n  'YY DD M',\n  'YYYY D MM',\n  'YY D MM',\n  'YYYY DD MM',\n  'YY DD MM',\n\n  //\n  'YY, MMM D',\n  'YY, MMMM D',\n  'YY, MMM DD',\n  'YY, MMMM DD',\n\n  'YYYY, MMM D',\n  'YYYY, MMMM D',\n  'YYYY, MMM DD',\n  'YYYY, MMMM DD',\n];\n\n// get patient data from ocr\nconst getUserData = (arr, patient) => {\n  let ocrWordResult = [];\n  const dob = patient.birthdate;\n  const socialSecurityNumberRegex = new RegExp('^(?!666|000|9\\\\d{2})\\\\d{3}-(?!00)\\\\d{2}-(?!0{4})\\\\d{4}$');\n\n  // get coordinates of patient name\n  ocrWordResult = getBoxes(patient.name, arr);\n  // loop date format with space to get coordinates\n  formatWithSpace.forEach(x => {\n    ocrWordResult.concat(getBoxes(moment(dob).format(x), arr));\n  });\n\n  // loop array of ocr words to match patient dob with date format that did not contain space\n  arr.forEach(word => {\n    if (word.text.length > 5 && word.text.match('.*\\\\d+.*') && (word.text.includes('/') || word.text.includes('-'))) {\n      const date = new Date(word.text);\n      // format 2 digit years eg. 47 -> 1947\n      if (Number(moment(date).format('YYYY')) > Number(moment().format('YYYY'))) {\n        date.setFullYear(Number('19' + moment(date).format('YYYY')\n          .substring(2, 4)));\n      }\n      // math patient dob\n      if (moment(date).format('DD-MM-YYYY') === moment(new Date(dob)).format('DD-MM-YYYY')) {\n        ocrWordResult.push(word);\n      }\n      // match patient social security number\n    } else if (word.text.length === 10 && word.text.includes('-') && socialSecurityNumberRegex.test(word.text)) {\n      ocrWordResult.push(word);\n    }\n  });\n\n  return ocrWordResult;\n};\n\n// get date from ocr\nconst getDate = (arr, dob) => {\n  const result = [];\n  const birthDate = new Date(dob);\n\n  arr.forEach(word => {\n    if (word.text.length > 5 && word.text.match('.*\\\\d+.*') && word.text.includes('/') || word.text.includes('-')) {\n      const regex  = new RegExp('^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z)?$');\n      const date = new Date(word.text);\n\n      if (regex.test(String(date))) {\n        if (date === birthDate) {\n          result.push(word);\n        }\n      }\n    }\n  });\n\n  return result;\n};\n\n// get social security number from ocr\nconst getSocialSecurityNumber = (arr) => {\n  const regex = new RegExp('^(?!666|000|9\\\\d{2})\\\\d{3}-(?!00)\\\\d{2}-(?!0{4})\\\\d{4}$');\n  const result = [];\n\n  arr.forEach(word => {\n    if (word.text.length === 10 && word.text.includes('-') && regex.test(word.text)) {\n      result.push(word);\n    }\n  });\n  return result;\n};\n\n// set Tesseract worker\nconst setWorker = (setWorker, setStatus, setProgress) => {\n  const { createWorker } = Tesseract;\n\n  // set worker from tesseract to callback\n  setWorker(createWorker({\n    logger: ({ status, progress }) =>  {\n      // set status from ocr to callback\n      if (setStatus) {\n        setStatus(status);\n      }\n\n      // set progress from ocr to callback\n      if (setProgress) {\n        setProgress(progress);\n      }\n    },\n  }));\n};\n\n// Recognize function from tesseract\nconst recognize = async(image, worker, lang) => {\n  try {\n    // set lang if none\n    if (!lang) {\n      lang = 'eng';\n    }\n\n    await worker.load();\n    await worker.loadLanguage(lang);\n    await worker.initialize(lang);\n    // recognize\n    const { data } = await worker.recognize(image);\n\n    // remap data to give each words an id\n    const ocrWords = data.words.map((word, i) => {\n      return {\n        ...word,\n        id: i\n      };\n    });\n\n    // replace result data words with remapped word list with id\n    const result = {\n      ...data,\n      words: ocrWords\n    };\n\n    return result;\n\n  } catch (error) {\n    console.log(error);\n    return [];\n  }\n};\n\n// Get ocr coordinates from word / sentence\n// input , ocrwords is wordlist from ocr recognize function\nconst getBoxes = (input, ocrWords) => {\n  // make input into an array / words splitted by spaces\n  const arrInput = input.split(' ').filter(word => word !== '');\n\n  const ocrWordList = [];\n\n  // map input array\n  arrInput.map(inputText => {\n    // map each words to find word that match input\n    ocrWords.forEach((word) => {\n      if (word.text.toLowerCase() === inputText.toLowerCase()) ocrWordList.push(word);\n    });\n  });\n\n  // sort by id so words will be sorted by line and from the left\n  ocrWordList.sort(function(a, b) {\n    return a.id - b.id;\n  });\n  \n  let OcrWordsResult = [];\n  \n  ocrWordList.forEach((currentOcrWord, i) => {\n    // initialize bbox\n    const bbox = {\n      ...currentOcrWord,\n      bbox: {\n        x0: currentOcrWord.bbox.x0,\n        y0: currentOcrWord.bbox.y0,\n        x1: currentOcrWord.bbox.x1,\n        y1: currentOcrWord.bbox.y1,\n      },\n      id: [currentOcrWord.id],\n      key: i\n    };\n \n    if (i > 0) {\n    // Check if the previous ocr word has an id that is one less than this ocr word's id. This means\n    // that the ocr words are adjacent in the image and the current ocr word is to the right and down\n    // relative to the previous ocr word.\n      if (currentOcrWord.id - ocrWordList[i - 1].id === 1) {\n        // Find a result (merged ocr words) that contains the previous ocr word's id, this will be\n        // the existing set of merged ocr words that we add this word to\n        OcrWordsResult.forEach((res, indexRes) => {\n          const indexId = res.id.indexOf(ocrWordList[i - 1].id);\n          if (indexId > -1) {\n            // Merge the current ocr word into the merged ocr word collection that it is adjacent to by\n            // extending the lower right bounded box corner to match the lower right corner of the\n            // current ocr word's bounded box\n            OcrWordsResult[indexRes] = {\n              ...OcrWordsResult[indexRes],\n              bbox: {\n                ...OcrWordsResult[indexRes].bbox,\n                x1: currentOcrWord.bbox.x1,\n                y1: currentOcrWord.bbox.y1,\n              },\n              id: [...OcrWordsResult[indexRes].id, currentOcrWord.id]\n            };\n          }\n        });\n      } else {\n        OcrWordsResult.push(bbox);\n      }\n    } else {\n      OcrWordsResult.push(bbox);\n    }\n  });\n\n  // filter out any words that only matches parts of the input\n  OcrWordsResult = OcrWordsResult.filter(ocrWords => ocrWords.id.length === arrInput.length);\n \n  return OcrWordsResult;\n};\n\nexport {\n  recognize,\n  getBoxes,\n  setWorker,\n  getSocialSecurityNumber,\n  getDate,\n  getUserData\n};","/Users/venecia/rebel/ocr-tesseract/src/reportWebVitals.js",[],"/Users/venecia/rebel/ocr-tesseract/src/DrawAnnotations/index.jsx",[],"/Users/venecia/rebel/ocr-tesseract/src/index.js",[],{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","severity":1,"message":"38","line":133,"column":61,"nodeType":"39","messageId":"40","endLine":133,"endColumn":63},{"ruleId":"37","severity":1,"message":"38","line":133,"column":88,"nodeType":"39","messageId":"40","endLine":133,"endColumn":90},{"ruleId":"41","severity":1,"message":"42","line":226,"column":26,"nodeType":"43","messageId":"44","endLine":226,"endColumn":28},"no-native-reassign",["45"],"no-negated-in-lhs",["46"],"no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation"]